`/*
  *  This is a library file of the module, containing functions implementing all logic 
  *  of actual copying and patching.
  */
	

	



/** For a given portrait name `basename`, check for existance of a matching '<basename>.2da' file
  * containing a list of game creatures which should be updated with the portrait `basename`.
  * The file should consist of any lines with a single column each, interpreted as the 
  * creature code matching an existing '<creature>.cre' file.
  *
  * Any existing creatures will have their smaller portrait set to `basename`. 
  * The large portrait entry is determined based on existance of matching portrait files next
  * to '<basename>.[bmp|ref]'. If `basename` ends with an 'M' and there is a matching '*L.bmp' 
  * or '*L.ref' file in the `dir` directory, it is taken as the larger portrait. Otherwise,
  * if `basename` ends with an 'S' and a '*M.bmp' or '*L.bmp' (or '.ref') file with the same prefix 
  * exists, it becomes the larger portrait of the creature instead. In case both searches fail,
  * `basename` itself is used also as the larger portrait entry.
  * 
  * As a consequence, one should create a '.2da' file for the smaller of the two portraits that
  * should be used.
  */  
DEFINE_ACTION_FUNCTION update_creatures
	STR_VAR
		/** Directory with the portrait files being handled (most typically specific to an individual npc). */
		dir = ~~
		/** File name without the '.bmp' (or '.ref') extension which is being copied. */
		basename = ~~
	RET
		/** Number of game creature files affected (including those were no actual change was necessary). */
		creatures_patched = 0
	BEGIN
		//read file with each line containing a creature updated with the current portrait
		COPY  ~%dir%/%basename%.2da~ ~%empty_dir%~  //no copying, simple read
			//determine if there is also a matching larger potrait to use
			OUTER_INNER_PATCH_SAVE largesize ~%basename%~ BEGIN //search for portraitM if this is portraitS
				REPLACE_TEXTUALLY CASE_INSENSITIVE EVALUATE_REGEXP ~S$~ ~M~
			END
			
			PATCH_IF (largesize STR_EQ basename) OR NOT (
			          FILE_EXISTS ~%dir%/%largesize%.bmp~ OR FILE_EXISTS ~%dir%/%largesize%.ref~) THEN BEGIN
				//search for portraitL if this is portraitS/portraitM	   
				OUTER_INNER_PATCH_SAVE largesize ~%basename%~ BEGIN 
					REPLACE_TEXTUALLY CASE_INSENSITIVE EVALUATE_REGEXP ~[SM]$~ ~L~
				END
				PATCH_IF (largesize STR_EQ basename) OR NOT (FILE_EXISTS ~%dir%/%largesize%.bmp~ 
						      OR FILE_EXISTS ~%dir%/%largesize%.ref~) THEN BEGIN
					//search for portraitG if this is portraitS/portraitM/portraitL
					OUTER_INNER_PATCH_SAVE largesize ~%basename%~ BEGIN 
						REPLACE_TEXTUALLY CASE_INSENSITIVE EVALUATE_REGEXP ~[SML]$~ ~G~
					END
					PATCH_IF NOT (FILE_EXISTS ~%dir%/%largesize%.bmp~ THEN BEGIN //fallback to using this image for both small and large portraits.
						OUTER_TEXT_SPRINT largesize ~%basename%~
					END
				END
			END
			
			COUNT_2DA_ROWS 1 creature_count
			
			FOR (i = 0; i < creature_count; ++i) BEGIN
				READ_2DA_ENTRY i 0 1 creature
			
				INNER_ACTION BEGIN
					COPY_EXISTING ~%creature%.cre~ ~override~
						SET creatures_patched += 1
						WRITE_EVALUATED_ASCII 0x34 ~%basename%~ #8 
						WRITE_EVALUATED_ASCII 0x3C ~%largesize%~ #8
					BUT_ONLY_IF_IT_CHANGES
				END									
			END
		IF_EXISTS BUT_ONLY_IF_IT_CHANGES
	
	END
	
	

	
	
/** Similar to update_creatures, verifies for the existance of the given 2da file and returns
  * the number of creatures listed in that file that actually exist in the game. The returned
  * value is the same that would be returned by update_creatures with corresponding parameters,
  * and the file must be a '.2da' file with a creature id (without the '.cre' extension) to update
  * in each line.
  */  
DEFINE_ACTION_FUNCTION patched_creatures
	STR_VAR
		file = ~~
	RET
		number = 0
	BEGIN
		LAF base_file_name STR_VAR file = ~%file%~ extension = ~\(bmp\|ref\|2da\)~
			RET basename match END
		ACTION_IF match THEN BEGIN
			OUTER_TEXT_SPRINT creaturefile ~%basename%.2da~
			ACTION_IF NOT FILE_EXISTS ~%creaturefile%~ THEN BEGIN
				OUTER_INNER_PATCH_SAVE smaller ~%basename%~ BEGIN
					REPLACE_TEXTUALLY EVALUATE_REGEXP ~G$~ ~L~ 
				END
				ACTION_IF NOT (~%smaller%~ STR_EQ ~%basename%~) AND 
				          (FILE_EXISTS ~%smaller%.ref~ OR FILE_EXISTS ~%smaller%.bmp~) THEN BEGIN
					OUTER_TEXT_SPRINT creaturefile ~%smaller%.2da~
					//ACTION_IF NOT FILE_EXISTS ~%creaturefile%~ THEN BEGIN
					//	OUTER_TEXT_SPRINT creaturefile ~~
					//END
				END ELSE BEGIN
					OUTER_INNER_PATCH_SAVE smaller ~%basename%~ BEGIN
						REPLACE_TEXTUALLY EVALUATE_REGEXP ~[GL]$~ ~M~
					END
					ACTION_IF NOT (~%smaller%~ STR_EQ ~%basename%~) AND
					          (FILE_EXISTS ~%smaller%.bmp~ OR FILE_EXISTS ~%smaller%.ref~) THEN BEGIN
						OUTER_TEXT_SPRINT creaturefile ~%smaller%.2da~
					END ELSE BEGIN
						OUTER_INNER_PATCH_SAVE smaller ~%basename%~ BEGIN
							REPLACE_TEXTUALLY EVALUATE_REGEXP ~[GLM]$~ ~S~
						END
						ACTION_IF NOT (~%smaller%~ STR_EQ ~%basename%~) AND
						          (FILE_EXISTS ~%smaller%.bmp~ OR FILE_EXISTS ~%smaller%.ref~) THEN BEGIN
							OUTER_INNER_PATCH_SAVE creaturefile ~%smaller%.2da~
						END
					END
				END
			END
		END
		COPY ~%creaturefile%~ ~%empty_dir%~ //just read, don't copy			
			COUNT_2DA_ROWS 1 creature_count
			
			FOR (i = 0; i < creature_count; ++i) BEGIN
				READ_2DA_ENTRY i 0 1 creature
				PATCH_IF FILE_EXISTS_IN_GAME ~%creature%.cre~ THEN BEGIN
					SET number += 1
				END
			END
		IF_EXISTS BUT_ONLY_IF_IT_CHANGES
	END
	
	
	
	
	





/** Checks if a given file should be copied/included in a file list based on 'exclude', 'include' and 'when' parameters.
  * A file is eligible iff all of these conditions are satisfied:
  *   - its extension is either '.ref' or '.bmp',
  *   - its base name is not included in the 'exclude' list,
  *   - its current existance in the game satisfies the 'when' parameter.
  * If 'targetname' parameter is specified, it is used as the target (renamed) portrait name instead of file's base name.
  */
DEFINE_ACTION_FUNCTION check_file_eligibility
	STR_VAR
		/** A path to a file, may be relative or absolute. */
		file = ~~
		/** Target name of the given portrait file. Specifying non-empty value indicates that the file
		  * will be renamed to the given name and that it should be used instead of file's base name
		  * when verifying the conditions for 'exclude' and 'when' parameters. Defaults to file's base name.
		  */
		targetname = ~~
		/** A list of file names (without extensions) that should be excluded from copying. 
		  * Each entry on the list should be surrounded with '/'. */
		exclude = ~~
		/** A list of file names (without extensions) on which a file must be present in order to be copied.
		  * If set to '*' it is considered to contain any possible file name. */
		include = ~*~		
		/** A switch which decides if a file should be copied based on its existance in the game. Can be one of:
		  * 'exists' - override only; the file must already exist in the game.
		  * 'not exists' - only new portraits; don't copy if the file already exists
		  * 'always' - all portraits; copy regardless of previous presence.
		  * 'used' - the portrait must exist, or a file with creatures to patch specifies at least one existing creature (default). 
		  * 'not used' - the portrait file must not exist and no creatures are being patched.
		  */
		when = ~used~
	RET
		eligible = 1
	BEGIN
		LAF decompose_file_path STR_VAR file = ~%file%~
			RET dir filename basename extension END
			
		ACTION_IF targetname STR_EQ ~~ THEN BEGIN
			OUTER_TEXT_SPRINT targetname ~%basename%~
		END
		
		ACTION_IF NOT ~%extension%~ STRING_EQUAL_CASE ~bmp~ AND NOT ~%extension%~ STRING_EQUAL_CASE ~ref~ THEN BEGIN
			OUTER_SET eligible = 0
			WARN ~Unsupported portrait file type: '%file%'~
		//STRING_CONTAINS_REGEXP returns 0 on match!
		ELSE ACTION_IF NOT (exclude STRING_CONTAINS_REGEXP ~/%targetname%/~) THEN BEGIN
			LOG ~          excluding file '%targetname%' (%file%)~
		ELSE ACTION_IF NOT (include STR_EQ ~*~) AND (include STRING_CONTAINS_REGEXP ~/%targetname%/~) THEN BEGIN
			LOG ~          ignoring '%targetname%' (%file%): not included in the white list.~
		END ELSE ACTION_IF NOT when STR_EQ ~always~ BEGIN
			ACTION_IF FILE_EXISTS_IN_GAME ~%targetname%.bmp~ THEN BEGIN
				ACTION_IF when STR_EQ ~not exists~ THEN BEGIN
					OUTER_SET eligible = 0
					LOG ~          ignoring '%targetname%' (%filename%): file exists in the game.~
				END
			END ELSE BEGIN
				ACTION_IF when STR_EQ ~exists~ THEN BEGIN
					OUTER_SET eligible = 0
					LOG ~          ignoring '%targetname%' (%file%): file does not exist in the game.~
				END ELSE ACTION_IF when STR_EQ ~used~ THEN BEGIN
					LAF patched_creatures STR_VAR file = ~%dir%/%targetname%.2da~
						RET eligible = number END
					ACTION_IF NOT eligible THEN BEGIN
						LOG ~          ignoring '%targetname%' (%file%): file does not exist and no creatures to patch.~
					END
				END ELSE ACTION_IF when STR_EQ ~not used~ THEN BEGIN
					LAF patched_creatures STR_VAR file = ~%dir%/%targetname%.2da~
						RET patched = number END
					ACTION_IF patched THEN BEGIN
						OUTER_SET eligible = 0
						LOG ~          ignoring '%targetname%' (%filename%): file used to patch creatures.~
					END
				END
			END
		END
	
	END
	
	
	
	


	
/** Copy a single portrait file, possibly following a chain of file references (quasi symbolic links).
  * First verifies that the file should be copied at all, based on whether the target portrait already
  * exists in the game and passed overwrite flags. If so, and %path% denotes a '.bmp' file, it is simply
  * copied. Otherwise, if it ends with '.ref', its contents are treated as the path to the target file, 
  * relative to the mod folder, which is then followed recursively. The path can, but doesn't have to,
  * include the '.bmp'/'.ref' extension. In the latter case, existing files with any of these extensions
  * are valid targets. In case of unsupported file extension or a link without a target, a warning 
  * is printed and `0` is returned as %copied%.
  *
  * @returns non-zero iff the file has been copied.
  */	
DEFINE_ACTION_FUNCTION copy_portrait
	INT_VAR
		/** Do not copy, simply resolve any file refs and return `1` if they point to a file that would be copied. */
		list_only = 0
		/** When set to 1 denotes that this is a recursive call being the result of resolving a ref file. */
		chain_call = 0
	STR_VAR
		/** Path to the file that should be copied, either a bmp or symlink-like '.ref'. */
		file = ~~
		/** Target directory to which the final .bmp file should be copied. */
		target = ~~
		/** Target game resource name, without the .bmp extension. */
		name = ~~
		/** List of files to exclude in the shared string format: [/<basename>/]*. */
		exclude = ~~
		include = ~*~
		/** Switch which decides if a file should be copied based on its existance in the game. Can be one of:
		  * 'exists' - override only; the file must already exist in the game.
		  * 'not exists' - only new portraits; don't copy if the file already exists
		  * 'always' - all portraits; copy regardless of previous presence.
		  * 'used' - the portrait must exist, or a file with creatures to patch specifies at least one existing creature (default). 
		  * 'not used' - the portrait file must not exist and no creatures are being patched.
		  */
		when = ~used~ 
	RET
		/** Return code specifying if the file was copied successfully. 
		  * If %list_only% is set, this will be `1` if the file *would* be copied. */
		copied = 1
	BEGIN

		ACTION_IF NOT FILE_EXISTS ~%file%~ THEN BEGIN
			ACTION_IF FILE_EXISTS ~%file%.bmp~ THEN BEGIN
				OUTER_TEXT_SPRINT file ~%file%.bmp~
			END ELSE ACTION_IF FILE_EXISTS ~%file%.ref~ THEN BEGIN
				OUTER_TEXT_SPRINT file ~%file%.ref~
			END ELSE BEGIN
				LOG ~          ignoring '%name%': '%file%' (referenced file does not exist)~
				OUTER_SET copied = 0
			END
		END	
		LAF decompose_file_path STR_VAR file = ~%file%~
			RET basename extension END
			
		ACTION_IF name STR_EQ ~~ THEN BEGIN
			OUTER_TEXT_SPRINT name ~%basename%~
		END
		
		ACTION_IF copied THEN BEGIN
			LAF check_file_eligibility 
				STR_VAR 
					file = ~%file%~ targetname = ~%name%~ 
				    exclude = ~%exclude%~ include = ~%include%~ when = ~%when%~
				RET copied = eligible END
			ACTION_IF copied THEN BEGIN
				ACTION_IF ~%extension%~ STR_EQ ~bmp~ THEN BEGIN //file name ends with '.bmp'
					ACTION_IF list_only THEN BEGIN
						LOG ~          '%name%': '%file%'~
					END ELSE BEGIN
						COPY ~%file%~ ~%target%/%name%.bmp~
					END
				END ELSE ACTION_IF ~%extension%~ STR_EQ ~ref~ BEGIN //file name ends with '.ref'
					LAF ref_target STR_VAR reffile = ~%file%~
						RET newpath = target END
					ACTION_IF NOT ~%newpath%~ STR_EQ ~~ THEN BEGIN
						ACTION_IF NOT chain_call THEN BEGIN
							LOG ~          '%name%':~
						END
						LOG ~            '%file%'	=> %newpath%~
						LAF copy_portrait 
							INT_VAR list_only = list_only chain_call = 1
							STR_VAR 
								file = ~%MOD_FOLDER%/%newpath%~ 
								name = ~%name%~ 
								target = ~%target%~ 
								when = ~always~ 
							RET copied END
					END
				END ELSE BEGIN
					WARN ~Unsupported portrait file type: %file%~
					OUTER_SET copied = 0
				END
			END
		END	
	END
	
	


	
	
/** Copies portrait files listed in an aggregate `2da` 2-column file `refsfile` 
  * (which should have a '.refs' extension). The first column of the file carries
  * the base name of the target portrait file (without a '.bmp' extesion, for example 'ImoenM').
  * The second column is a path to the file which should be copied (and possibly renamed)
  * to directory `%target%` and should be relative to `%MOD_FOLDER%` directory. 
  * It should point to either a '.bmp' or a '.ref' file, and is followed by delegation to `copy_portrait`.
  * The parameters driving the selection of files are interpreted in the same way as by
  * `copy_npc_portraits` function, and similarly, the return value contains the list of
  * files (entries from the first column) which were (or would  be) actually overriden.
  */
DEFINE_ACTION_FUNCTION copy_portrait_refs
	INT_VAR
		/** Don't copy anything, but otherwise behave no differently and return the list of files that 
		  * would be copied were this flag not set. */
		list_only = 0
	STR_VAR
		/** Path to the `.refs` 2da file containing the target name -> source file pairs. */
		refsfile = ~~
		/** Directory to which all files should be copied. */
		target = ~~
		/** List of files to exclude in the shared string format: [/<basename>/]*. */
		exclude = ~~
		include = ~*~
		/** Switch which decides if a file should be copied based on its existance in the game. Can be one of:
		  * 'exists' - override only; the file must already exist in the game.
		  * 'not exists' - only new portraits; don't copy if the file already exists
		  * 'always' - all portraits; copy regardless of previous presence.
		  * 'used' - the portrait must exist, or a file with creatures to patch specifies at least one existing creature (default). 
		  * 'not used' - the portrait file must not exist and no creatures listed to be patched with it.
		  */
		when = ~used~
	RET
		/** Concatenated list of copied files in the shared format: [/<basename>/]*. */ 
		filelist
	BEGIN
		LOG ~        %refsfile%:~
		LAF refs_targets STR_VAR refsfile = ~%refsfile%~
			RET count RET_ARRAY refs END
		ACTION_IF count THEN BEGIN
			ACTION_PHP_EACH refs AS basename => path BEGIN
				LAF copy_portrait 
					INT_VAR list_only = list_only 
					STR_VAR file = ~%MOD_FOLDER%/%path%~ target = ~%target%~ name = ~%basename%~ 
							exclude = ~%exclude%~ include = ~%include%~ when = ~%when%~
					RET	proceed = copied END
				ACTION_IF proceed THEN BEGIN
					OUTER_TEXT_SPRINT filelist ~%filelist%/%basename%/~
				END
			END
		END
	END
	




	
/** Copies portraits from a single directory. This function is called from copy_npc_portraits
  * for every npc-level directory.
  */
DEFINE_ACTION_FUNCTION copy_portrait_set
	INT_VAR
		/** Copy no files, simply return the list of files that would be copied. 
		  * Return value is the same as without this flag. */
		list_only = 0
		/** Allow the user to select between alternative portraits if available. Superceeded by list_only=1. */
		defaults = -1
	STR_VAR 
		/** The complete path to the directory with the portrait files. */ 
		dir = ~~
		/** Target directory into which all files are (flatly) copied. */
		target = ~override~
		/** List of file names (without extensions) that should be excluded from copying. 
		  * Each entry on the list should be surrounded with '/'. */
		exclude = ~~
		include = ~*~
		/** Switch which decides if a file should be copied based on its existance in the game. Can be one of:
		  * 'exists' - override only; the file must already exist in the game.
		  * 'not exists' - only new portraits; don't copy if the file already exists
		  * 'always' - all portraits; copy regardless of previous presence.
		  * 'used' - the portrait must exist, or a file with creatures to patch specifies at least one existing creature (default). 
		  * 'not used' - the portrait file must not exist and no creatures would be updated to use it.
		  */
		when = ~used~
	RET
		/** List of base names of copied files. Each name is surrounded with '/' on both sides:
		  * unless the list is empty, string starts and ends with '/' and each two files are separated by '//'. */
		filelist = ~~
	BEGIN
		
		ACTION_DEFINE_ARRAY portraits BEGIN END
		GET_FILE_ARRAY portraits ~%dir%~ ~^.+\.\(bmp\|ref\|refs\)$~ 
		
		ACTION_PHP_EACH portraits AS _ => path BEGIN //copy all new bmp files to target
			
			LAF decompose_file_path STR_VAR file = ~%path%~
				RET filename basename extension END					
			
			//A 2-column table with target portrait name and path to the file
			ACTION_IF ~refs~ STR_EQ ~%extension%~ THEN BEGIN
				LAF copy_portrait_refs 
					INT_VAR list_only = list_only
					STR_VAR 
						refsfile = ~%path%~ 
						target = ~%target%~
						exclude = ~%exclude%~
						include = ~%include%~
						when = ~%when%~
					RET refs = filelist END
				OUTER_TEXT_SPRINT filelist ~%filelist%%refs%~
				
			END ELSE BEGIN //single file (or file ref)
				LAF copy_portrait 
					INT_VAR list_only = list_only
					STR_VAR
						file = ~%path%~
						target = ~%target%~
						name = ~%basename%~
						exclude = ~%exclude%~
						include = ~%include%~
						when = ~%when%~
					RET proceed = copied END
				ACTION_IF proceed THEN BEGIN
					OUTER_TEXT_SPRINT filelist ~%filelist%/%basename%/~
				END
			END			
		END
	
	END
	




	
/** For a portrait set given as a single directory (specific to an npc), check for
  * the existance of alternative portrait sets and, unless the run is non-interactive
  * or set to always use default values, present the alternative portraits to the user
  * and prompt them for a selection of one of them. The entries of the list are verbatim
  * folder names under '<dir>/alteratives' in the alphabetical order.
  *
  * The alternatives are searched for in an 'alteratives' directory next to the
  * default portrait files for an npc. If such a directory exists and contains more
  * than one subdirectory, they are assumed to contain portrait sets which can
  * be used to substitute default portraits in the `dir` directory. All these directories
  * should contain the exact same set of files in the respect to their base names and portrait
  * dimensions. Allowed extensions are '.bmp' and '.ref' as handled by the `copy_portrait`
  * function and can differ between the alternative directories and the default npc
  * directory. In particular, it makes sense to have the default portrait be files simply
  * '.ref' file links pointing to actual portraits (or refs) inside of the alternative directory.
  * 
  * Additionally, if the %show_alternatives% global variable is set and an 'alternatives.html' file is present
  * in the proper npc directory (next to the 'alternatives' directory), a viewer is launched to preview the 
  * portraits, providing the install run is interactive. Any lacking files will result in mismatched portraits.
  *
  * If/when the choice of one of the portrait sets is made, aside from copying those files and
  * overriding any already existing portraits, *the portrait files from %dir% are all deleted*.
  * In their place, for every file copied, a '.ref' file is created with the same name, pointing to
  * to the copied file. This makes the choice persistent and changes the 'default' portrait set
  * for the character. In effect, any future automatic overrides of these files when copying will
  * use the previously copied files, without generally undesirable effect of reverting to original portraits.
  *
  * It is the responsibility of the caller to verify if the run is interactive or if for
  * any other reasons the user shouldn't be prompted with the choice but default values should
  * be used instead.
  */
DEFINE_ACTION_FUNCTION select_alternative_portraits
	STR_VAR
		/** The directory corresponding to a portrait set (for example, 
		  * '%MOD_FOLDER%/canonnpcs/bgee/female/Imoen'). */
		dir = ~~
		/** The name of the `dir` directory (with the path prefix stripped, i.e. 'Imoen'). */
		npcname = ~~
		/** Directory to which the files should be copied. */
		target = ~override~
	BEGIN
		ACTION_IF DIRECTORY_EXISTS ~%dir%/alternatives~ THEN BEGIN
			GET_DIRECTORY_ARRAY versions ~%dir%/alternatives~ ~%any_dir%~
						
			OUTER_SET altcount = 0
			ACTION_PHP_EACH versions AS _ => alt BEGIN							
				OUTER_SET altcount += 1
			END
			
			ACTION_IF altcount > 1 THEN BEGIN
				OUTER_SPRINT prompt @504
				PRINT ~%prompt% %npcname%:~
			
				OUTER_SET altcount = 0 //print alternative portrait dirs
				ACTION_PHP_EACH versions AS _ => altdir BEGIN
					LAF strip_prefix STR_VAR string = ~%altdir%~ prefix = ~%dir%/alternatives/~
						RET alt = suffix END				
					PRINT ~[%altcount%] %alt%~
					OUTER_SET altcount += 1
				END
				
				//Launch a viewer to show the user a preview of portraits to pick
				ACTION_IF show_alternatives AND FILE_EXISTS ~%dir%/alternatives.html~ THEN BEGIN
					AT_INTERACTIVE_NOW ~VIEW %dir%/alternatives.html~
				END
				
				OUTER_SET idx = altcount //read user choice into idx
				OUTER_WHILE (NOT IS_AN_INT %idx%) OR idx < 0 OR idx >= altcount BEGIN
					PRINT @505
					ACTION_READLN ~idx~
				END
					
				OUTER_SPRINT chosen $versions(~%idx%~)
				ACTION_CLEAR_ARRAY versions
				LOG ~%npcname% alternative %idx%: %chosen%~ 
				
				LAF delete_files STR_VAR dir = ~%dir%~ files = ~*~ END
				GET_FILE_ARRAY files ~%chosen%~ ~^[^/\\]+\.\(bmp\|ref\)$~
				
				//copy the files under chosen directory to override and create references in %dir%
				ACTION_PHP_EACH files AS _ => portrait BEGIN
					LAF base_file_name STR_VAR file = ~%portrait%~ dir = ~%chosen%~ extension = ~bmp\|ref~
						RET basename match END
					ACTION_IF NOT match THEN BEGIN
						FAIL ~Unsupported alternative portrait file type: [%portrait%]~
					END
					
					LAF copy_portrait 
						STR_VAR path = ~%portrait%~ name = ~%basename%~ target = ~%target%~ when = ~always~
						RET copied
					END
					ACTION_IF NOT copied THEN BEGIN
						FAIL ~Could not copy alternative portrait for %npcname%: [%portrait%]~
					END
					
					//LAF delete_files STR_VAR dir = ~%dir%~ files = ~/%basename%/~ END
					LAF create_ref_file STR_VAR dir = ~%dir%~ name = ~%basename%~ path = ~%portrait%~ END
					
				END
				
			END
		END
	
	END











DEFINE_ACTION_FUNCTION directory_defaults
	INT_VAR
		defaults = -1
	STR_VAR
		npctype = ~~
		game = ~~
		gender = ~male\|female\|other~
		name = ~~
	RET 
		defaults //= 0
		npctype 
		game //= ~~
		gender //= ~male\|female\|other~
		name //= ~~		
	BEGIN
		ACTION_IF ~%npctype%~ STR_EQ ~~ THEN BEGIN
			OUTER_TEXT_SPRINT npctype ~%any_npc_type%~
		END
		ACTION_IF (~%game%~ STRING_EQUAL ~~) THEN BEGIN 
			OUTER_TEXT_SPRINT game ~%game_dirs%~
		END
		ACTION_IF (~%name%~ STRING_EQUAL ~~) THEN BEGIN
			OUTER_TEXT_SPRINT name ~%any_dir%~
		END
		ACTION_IF defaults < 0 THEN BEGIN
			OUTER_SET defaults = use_default_portraits
		END

	END
		
	
	
	
	
/** Copy portrait files which path is covered by a sequence of regular expressions for individual directories.
  *	The directories on path serve as role/content/gender filter and thus subtries of the collection can be
  * excluded or included. Only the first argument is mandatory, the rest will match all standard subdirectories.
  * If you wish to copy portraits of NPCs regardless of their role, choose %any_npc_type% for npctype.
  *  
  * This function concers itself only if the standard '.bmp' files, symlink-like file refs '.ref' containing
  * a path to the actual file (see `copy_portrait` function's documentation) and '.refs' files aggregating
  * several file links (see `copy_portrait_refs` function's documetation).  Additionally, if a matching 
  * file with a '2da' extension is found for a portrait (i.e. an ImoenM.2da for ImoenM.bmp), it is assumed to
  * contain a list of creature codes (their file names without the '.CRE' extension), one creature file per line,
  * which should be patched with the corresponding portrait. It will be set as both the large and medium sized 
  * portrait (offsets 0x34 and 0x3C) for the creatures, unless:
  * a) the file name ends with 'M' (i.e. ImoenM.bmp) and a corresponding 'L' file exists in the same directory 
  *   (ImoenL.bmp), in which case it is set as the smaller portrait and the 'L' file is set as the larger portrait;
  * b) the file name ends with 'S' (i.e. ImoenS.bmp) and a corresponding 'M' or 'L' file exist in the same 
  *    directory (ImoenM.bmp), in which case it is set as the smaller portrait and the 'M' or 'L' file (in this order)
  *    is set as the larger portrait.
  * In the above case of matching portrait sets, only one '2da' file should be present, or the actions will
  * be applied in undetermined order and overwrite their modifications. See the `update_creatures` function
  * for details.
  *
  * If the `defaults` parameter is zero, or it is negative and the %use_default_portraits% global flag is clear, 
  *`the list_only` parameter is false, and an 'alternatives' directory is present in the npc folder with portrait 
  * files, the user will be prompted with the list of directories and asked to pick one. They should be named 
  * descriptively, with a limitation of disallowed characters '/', '\', '.', and are assumed to contain a file 
  * with the same name for all '.bmp'/'.ref' files in the parent npc directory. 
  * See the `select_alternative_portraits` for more.
  *
  * @returns filelist a string with concatenated portrait names, each surrounded by a pair of '/'.
  * @returns names a string with concatenated names of npc-level directories from which files were copied.
  * @returns filemap - an assoc array mapping paths of every 'npc' (deepest level) directory afected to 
  *                  a string containing all portrait file names (without the .bmp extension) copied 
  *                  from that directory prefixed by '/', i.e. in the format of "\(/<base-file-name>\)*".
  *                  If no files where copied from a directory, it is mapped to an empty string. 
  *                  If no files where copied at all, the map contains a single entry ~~ => ~~.
  */
DEFINE_ACTION_FUNCTION copy_npc_portraits
	INT_VAR
		/** Copy no files, simply return the list of files that would be copied. 
		  * Return value is the same as without this flag. */
		list_only = 0
		/** Allow the user to select between alternative portraits if available. */
		defaults = -1
		/** If not zero, the user will be prompted about every portrait set (npc directory). */
		ask_each = 0
	STR_VAR 
		/** Regexp for name of root directory with npc portraits (alternative from npcs|modnpcs|plotnpcs etc.)*/
		npctype = ~~
		/** Regexp for game directories to cover: bgee|sod|bg2ee */	
		game = ~~
		/** Regexp for gender directory grouping individual npcs. */
		gender = ~male\|female\|other~ 
		/** Regexp for npc directory (i.e. name/identifier). */
		name = ~~ 
		/** Switch which decides if a file should be copied based on its existance in the game. Can be one of:
		  * 'exists' - override only; the file must already exist in the game.
		  * 'not exists' - only new portraits; don't copy if the file already exists
		  * 'always' - all portraits; copy regardless of previous presence.
		  * 'used' - the portrait must exist, or a file with creatures to patch specifies at least one existing creature (default). 
		  * 'not used' - the portrait file must not exist and no creatures would be updated to use it.
		  */
		when = ~used~
		/** Target directory into which all files are (flatly) copied. */
		target = ~override~
		/** List of file names (without extensions) that should be excluded from copying. 
		  * Each entry on the list should be surrounded with '/'. */
		exclude = ~~
		include = ~*~
	RET
		/** Number of portrait sets (bottom level dirs) for which at least one file has been copied/listed.
		  * Due to weidu limitations returned array filemap is undefined if npccount==0.
		  */
		npccount = 0
		/** List of base names of copied files. Each name is surrounded with '/' on both sides:
		  * unless the list is empty, string starts and ends with '/' and each two files are separated by '//'. */
		filelist = ~~
		/** List of directories matching %name% which contained at least one file included in %filelist%. 
		  * Directories from all %npctype%/%game%/%gender% branches are listed together and separated by the regexp 
		  * alternative symbol '\|'.
		  */		
		names = ~~
	RET_ARRAY
		filemap
	BEGIN
		//OUTER_TEXT_SPRINT filelist ~~
		//OUTER_TEXT_SPRINT names ~~
/*		
		ACTION_IF (~%game%~ STRING_EQUAL ~~) THEN BEGIN 
			OUTER_TEXT_SPRINT game ~%game_dirs%~
		END
		ACTION_IF (~%name%~ STRING_EQUAL ~~) THEN BEGIN
			OUTER_TEXT_SPRINT name ~%any_dir%~
		END
		ACTION_IF defaults < 0 THEN BEGIN
			OUTER_SET defaults = use_default_portraits
		END
*/
		LAF directory_defaults 
			INT_VAR defaults = defaults
			STR_VAR game = ~%game%~ gender = ~%gender%~ name = ~%name%~
			RET defaults game gender name END
		
		ACTION_IF NOT list_only THEN BEGIN
			ACTION_IF when STR_EQ ~exists~ THEN BEGIN
				OUTER_TEXT_SPRINT copy_msg @082
			END ELSE BEGIN
				OUTER_TEXT_SPRINT copy_msg @081
			END
			OUTER_TEXT_SPRINT when_msg @080
			PRINT ~%copy_msg% %npctype%/%game%/%gender%/%name%/	=> '%target%'  %when_msg%: %when%~
		END ELSE BEGIN
			LOG ~List portraits from %npctype%/%game%/%gender%/%name%/ when %when%~
		END
		ACTION_IF NOT exclude STR_EQ ~~ THEN BEGIN
			LOG ~Exclude: %exclude%~
		END
		ACTION_IF NOT include STR_EQ ~*~ THEN BEGIN
			LOG ~Include: %include%~
		END
		
		ACTION_IF NOT (list_only OR DIRECTORY_EXISTS ~%target%~) THEN BEGIN
			MKDIR ~%target%~
		END
		
		ACTION_DEFINE_ASSOCIATIVE_ARRAY filemap BEGIN END
		
		GET_DIRECTORY_ARRAY roots ~%MOD_FOLDER%~ ~^\(%npctype%\)$~ 
		
		ACTION_PHP_EACH roots AS _ => rootdir BEGIN
			GET_DIRECTORY_ARRAY gamedirs ~%rootdir%~ ~^\(%game%\)$~	
			LAF strip_prefix STR_VAR string = ~%rootdir%~ prefix = ~%MOD_FOLDER%/~ 
				RET root = suffix END			
			LOG ~%root%:~
			
			ACTION_PHP_EACH gamedirs AS _ => gamedir BEGIN 
				GET_DIRECTORY_ARRAY genders ~%gamedir%~ ~^\(%gender%\)$~
				LAF strip_prefix STR_VAR string = ~%gamedir%~ prefix = ~%rootdir%/~ 
					RET gamename = suffix END
				LOG ~  %gamename%:~
				
				ACTION_PHP_EACH genders AS _ => genderdir BEGIN
					GET_DIRECTORY_ARRAY npcs ~%genderdir%~ ~^\(%name%\)$~
					LAF strip_prefix STR_VAR string = ~%genderdir%~ prefix = ~%gamedir%/~
						RET sex = suffix END
					LOG ~    %sex%:~
				
					ACTION_PHP_EACH npcs AS _ => npcdir BEGIN
						LAF strip_prefix STR_VAR string = ~%npcdir%~ prefix = ~%genderdir%/~
							RET npcname = suffix END
						LOG ~      %npcname%:~
						
						OUTER_TEXT_SPRINT copied_files ~~
						OUTER_SET proceed = 0
						ACTION_IF ask_each && NOT list_only THEN BEGIN
							LOG ~        verifying if there are any files to be copied before asking the user...~
							LAF copy_portrait_set 
								INT_VAR list_only = 1 defaults = 1
								STR_VAR dir = ~%npcdir%~ when = ~%when%~ exclude = ~%exclude%~ include = ~%include%~ 
								RET copied_files = filelist END
							
							ACTION_IF NOT (copied_files STR_EQ ~~) THEN BEGIN
								OUTER_TEXT_SPRINT copied_files ~~
								OUTER_SPRINT prompt_prefix @508
								OUTER_SPRINT prompt_suffix @509
								OUTER_TEXT_SPRINT decision ~~ 
								OUTER_WHILE NOT ((decision STRING_EQUAL_CASE ~I~) || (decision STRING_EQUAL_CASE ~N~)) BEGIN
									PRINT ~  %prompt_prefix% %npcname%%prompt_suffix% ~								
									ACTION_READLN ~decision~									
								END
								ACTION_IF (decision STRING_EQUALS_CASE ~I~) THEN BEGIN
									LOG ~        installing %npcname%:~
									OUTER_SET proceed = 1
								END 
							END								
						END ELSE BEGIN
							OUTER_SET proceed = 1
						END
						
						ACTION_IF proceed THEN BEGIN
							LAF copy_portrait_set
								INT_VAR list_only = list_only defaults = defaults
								STR_VAR dir = ~%npcdir%~ target = ~%target%~
								        when = ~%when%~ exclude = ~%exclude%~ include = ~%include%~ 
								RET copied_files = filelist END
						END
						
						ACTION_IF NOT (~%copied_files%~ STR_EQ ~~) THEN BEGIN
							ACTION_IF names STR_EQ ~~ THEN BEGIN
								OUTER_TEXT_SPRINT names ~%npcname%~
							END ELSE BEGIN
								OUTER_TEXT_SPRINT names ~%names%\|%npcname%~
							END
							ACTION_IF NOT list_only THEN BEGIN
								LAF update_creatures 
									STR_VAR dir = ~%npcdir%~ basename = ~%basename%~ 
									RET creatures = creatures_patched END
								ACTION_IF creatures THEN BEGIN
									LOG ~        patched %creatures% creatures.~
								END
								ACTION_IF NOT defaults THEN BEGIN
									//verify if there is an 'alternatives' subdirectory with alternate files
									LAF select_alternative_portraits STR_VAR
										dir = ~%npc%~ npcname = ~%npcname%~ target = ~%target%~
									END
								END
							END
													
							OUTER_SET npccount += 1
							ACTION_DEFINE_ASSOCIATIVE_ARRAY filemap BEGIN ~%npcdir%~ => ~%copied_files%~ END
							OUTER_TEXT_SPRINT filelist ~%filelist%%copied_files%~
						END					
					END
					ACTION_CLEAR_ARRAY npcs
				END
				ACTION_CLEAR_ARRAY genders
			END
			ACTION_CLEAR_ARRAY gamedirs
		END
		ACTION_CLEAR_ARRAY roots
		
		LOG ~NPCs/sets: %names%~
		ACTION_IF list_only THEN BEGIN
			LOG ~Listed portraits: %filelist%~
		END ELSE BEGIN
			LOG ~Copied portraits: %filelist%~
		END
		
	END





	

	
/** A minimalistic wrapper over copy_npc_portraits which simply sets list_only = 1. */	
DEFINE_ACTION_FUNCTION list_npc_portraits
	STR_VAR 
		npctype = ~~
		game = ~~
		gender = ~male\|female\|other~ 
		name = ~~ 
		when = ~used~
		exclude = ~~
		include = ~*~
	RET
		npccount
		filelist
		names
	RET_ARRAY
		filemap
	BEGIN
		LAF copy_npc_portraits 
			INT_VAR list_only = 1 defaults = 1
			STR_VAR npctype = ~%npctype%~ game = ~%game%~ gender = ~%gender%~ name = ~%name%~
			        when = ~%when%~ exclude = ~%exclude%~ include = ~%include%~ target = ~~
			RET npccount filelist names
			RET_ARRAY filemap
		END
	END




	


/** Similar to copy_npc_portraits, but copies (or lists) also all files within optional alternatives directories.
  * As these primarily contain overrides for the default npc portraits from the parent directory, it makes
  * sense only if additional, uniquely named portrait files are also present. This is used for granting player
  * characters the alternative portraits of npcs who have these additional files named according to the PC scheme.
  * All parameters and returned values are the same as for copy_npc_portraits.
  */
DEFINE_ACTION_FUNCTION copy_npc_alternatives
	INT_VAR
		/** Copy no files, simply return the list of files that would be copied. 
		  * Return value is the same as without this flag. */
		list_only = 0
//		/** If not zero, the user will be prompted about every portrait set (npc directory). */
//		ask_each = 0
	STR_VAR 
		/** Regexp for name of root directory with npc portraits (alternative from npcs|modnpcs|plotnpcs etc.)*/
		npctype = ~~
		/** Regexp for game directories to cover: bgee|sod|bg2ee */	
		game = ~~
		/** Regexp for gender directory grouping individual npcs. */
		gender = ~male\|female\|other~ 
		/** Regexp for npc directory (i.e. name/identifier). */
		name = ~~ 
		/** Switch which decides if a file should be copied based on its existance in the game. Can be one of:
		  * 'exists' - override only; the file must already exist in the game.
		  * 'not exists' - only new portraits; don't copy if the file already exists
		  * 'always' - all portraits; copy regardless of previous presence.
		  * 'used' - the portrait must exist, or a file with creatures to patch specifies at least one existing creature (default). 
		  * 'not used' - the portrait file must not exist and no creatures would be updated to use it.
		  */
		when = ~always~
		/** Target directory into which all files are (flatly) copied. */
		target = ~override~
		/** List of file names (without extensions) that should be excluded from copying. 
		  * Each entry on the list should be surrounded with '/'. */
		exclude = ~~
		include = ~~
	RET
		/** Number of portrait sets (bottom level dirs) for which at least one file has been copied/listed.
		  * Due to weidu limitations returned array filemap is undefined if npccount==0.
		  */
		npccount = 0
		/** List of base names of copied files. Each name is surrounded with '/' on both sides:
		  * unless the list is empty, string starts and ends with '/' and each two files are separated by '//'. */
		filelist = ~~
		/** List of directories matching %name% which contained at least one file included in %filelist%. 
		  * Directories from all %npctype%/%game%/%gender% branches are listed together and separated by the regexp 
		  * alternative symbol '\|'.
		  */		
		names = ~~
	RET_ARRAY
		filemap
	BEGIN
		//OUTER_TEXT_SPRINT filelist ~~
		//OUTER_TEXT_SPRINT names ~~
/*		
		ACTION_IF (~%game%~ STRING_EQUAL ~~) THEN BEGIN 
			OUTER_TEXT_SPRINT game ~%game_dirs%~
		END
		ACTION_IF (~%name%~ STRING_EQUAL ~~) THEN BEGIN
			OUTER_TEXT_SPRINT name ~%any_dir%~
		END
		ACTION_IF defaults < 0 THEN BEGIN
			OUTER_SET defaults = use_default_portraits
		END
*/
		LAF directory_defaults 
			INT_VAR defaults = defaults
			STR_VAR game = ~%game%~ gender = ~%gender%~ name = ~%name%~
			RET defaults game gender name END
		
		ACTION_IF NOT list_only THEN BEGIN
			ACTION_IF when STR_EQ ~exists~ THEN BEGIN
				OUTER_TEXT_SPRINT copy_msg @082
			END ELSE BEGIN
				OUTER_TEXT_SPRINT copy_msg @081
			END
			OUTER_TEXT_SPRINT when_msg @080
			PRINT ~%copy_msg% %npctype%/%game%/%gender%/%name%/**	=> '%target%'	%when_msg%: %when%~
		END ELSE BEGIN
			LOG ~List portraits from %npctype%/%game%/%gender%/%name%/**	when: %when%~
		END
		ACTION_IF NOT exclude STR_EQ ~~ THEN BEGIN
			LOG ~Exclude: %exclude%~
		END
		ACTION_IF NOT include STR_EQ ~*~ THEN BEGIN
			LOG ~Include: %include%~
		END

		
		ACTION_IF NOT (list_only OR DIRECTORY_EXISTS ~%target%~) THEN BEGIN
			MKDIR ~%target%~
		END
		
		ACTION_DEFINE_ASSOCIATIVE_ARRAY filemap BEGIN END
		
		OUTER_SET npccount = 0
		GET_DIRECTORY_ARRAY roots ~%MOD_FOLDER%~ ~^\(%npctype%\)$~ 
		
		ACTION_PHP_EACH roots AS _ => rootdir BEGIN
			GET_DIRECTORY_ARRAY gamedirs ~%rootdir%~ ~^\(%game%\)$~	
			LAF strip_prefix STR_VAR string = ~%rootdir%~ prefix = ~%MOD_FOLDER%/~ 
				RET root = suffix END			
			LOG ~%root%:~
			
			ACTION_PHP_EACH gamedirs AS _ => gamedir BEGIN 
				GET_DIRECTORY_ARRAY genders ~%gamedir%~ ~^\(%gender%\)$~
				LAF strip_prefix STR_VAR string = ~%gamedir%~ prefix = ~%rootdir%/~ 
					RET gamename = suffix END
				LOG ~  %gamename%:~
				
				ACTION_PHP_EACH genders AS _ => genderdir BEGIN
					GET_DIRECTORY_ARRAY npcs ~%genderdir%~ ~^\(%name%\)$~
					LAF strip_prefix STR_VAR string = ~%genderdir%~ prefix = ~%gamedir%/~
						RET sex = suffix END
					LOG ~    %sex%:~
				
					ACTION_PHP_EACH npcs AS _ => npcdir BEGIN
						LAF strip_prefix STR_VAR string = ~%npcdir%~ prefix = ~%genderdir%/~
							RET npcname = suffix END
						LOG ~      %npcname%:~

/*						
						OUTER_TEXT_SPRINT copied_files ~~
						OUTER_SET proceed = 0

						ACTION_IF ask_each && NOT list_only THEN BEGIN
							LOG ~        verifying if there are any files to be copied before asking the user...~
							LAF copy_portrait_set 
								INT_VAR list_only = 1 defaults = 1
								STR_VAR dir = ~%npcdir%~ when = ~%when%~ exclude = ~%exclude%~ include = ~%include%~ target = ~~
								RET copied_files = filelist END
							
							ACTION_IF NOT (copied_files STR_EQ ~~) THEN BEGIN
								OUTER_TEXT_SPRINT copied_files ~~
								OUTER_SPRINT prompt_prefix @508
								OUTER_SPRINT prompt_suffix @509
								OUTER_TEXT_SPRINT decision ~~ 
								OUTER_WHILE NOT ((decision STRING_EQUAL_CASE ~I~) || (decision STRING_EQUAL_CASE ~N~)) BEGIN
									PRINT ~  %prompt_prefix% %npcname%%prompt_suffix% ~								
									ACTION_READLN ~decision~									
								END
								ACTION_IF (decision STRING_EQUALS_CASE ~I~) THEN BEGIN
									LOG ~        installing %npcname%:~
									OUTER_SET proceed = 1
								END 
							END								
						END ELSE BEGIN
							OUTER_SET proceed = 1
						END
						
						ACTION_IF proceed THEN BEGIN
							LAF copy_portrait_set
								INT_VAR list_only = list_only defaults = defaults
								STR_VAR dir = ~%npcdir%~ when = ~%when%~ exclude = ~%exclude%~ target = ~%target%~
								RET copied_files = filelist END
						END
*/
						//LAF copy_portrait_set 
						//	INT_VAR list_only = list_only defaults = 1
						//	STR_VAR dir = ~%npcdir%~ when = ~%when%~ exclude = ~%exclude%~ target = ~%target%~
						//	RET copied_files = filelist END
	
						ACTION_IF DIRECTORY_EXISTS ~%npcdir%/alternatives~ THEN BEGIN
							GET_DIRECTORY_ARRAY versions ~%npcdir%/alternatives~ ~%any_dir%~
							OUTER_TEXT_SPRINT copied_files ~~
							
							ACTION_PHP_EACH versions AS _ => versiondir BEGIN
								LAF strip_prefix STR_VAR string = ~%versiondir%~ prefix = ~%npcdir%/alternatives/~
									RET version = suffix END
								LOG ~        %version%:~
								
								LAF copy_portrait_set 
									INT_VAR list_only = list_only
									STR_VAR dir = ~%versiondir%~ target = ~%target%~
									        when = ~%when%~ exclude = ~%exclude%~ include = ~%include%~
									RET altlist END
								OUTER_TEXT_SPRINT copied_files ~%copied_files%%altlist%~
							END
							ACTION_CLEAR_ARRAY versions
						END ELSE BEGIN
							LAF copy_portrait_set 
								INT_VAR list_only = list_only 
								STR_VAR dir = ~%npcdir%~ target = ~%target%~
								        when = ~%when%~ exclude = ~%exclude%~ include = ~%include%~
								RET copied_files = filelist END
						END
	
						ACTION_IF NOT (~%copied_files%~ STR_EQ ~~) THEN BEGIN
							ACTION_IF names STR_EQ ~~ THEN BEGIN
								OUTER_TEXT_SPRINT names ~%npcname%~
							END ELSE BEGIN
								OUTER_TEXT_SPRINT names ~%names%\|%npcname%~
							END

							OUTER_SET npccount += 1
							ACTION_DEFINE_ASSOCIATIVE_ARRAY filemap BEGIN ~%npcdir%~ => ~%copied_files%~ END
							OUTER_TEXT_SPRINT filelist ~%filelist%%copied_files%~

						END	
							
				
					END
					ACTION_CLEAR_ARRAY npcs
				END
				ACTION_CLEAR_ARRAY genders
			END
			ACTION_CLEAR_ARRAY gamedirs
		END
		ACTION_CLEAR_ARRAY roots
		
		LOG ~NPCs/sets: %names%~
		ACTION_IF list_only THEN BEGIN
			LOG ~Listed portraits: %filelist%~
		END ELSE BEGIN
			LOG ~Copied portraits: %filelist%~
		END
		
	END





	
/** A light wrapper over `copy_npc_portraits`, which overrides all portraits
  * for the official joinable npcs in the game (assuming replacement exists).
  * It simply sets the following parameters: `when = ~exists~`,
  * `npctype = ~canonnpcs~` and `game = ~%any_game%~`. The `list_only` and `exclude`
  * parameters are passed to `copy_npc_portraits` and its returned value is
  * returned to the caller in `filelist`.
  */
DEFINE_ACTION_FUNCTION copy_canon_npc_defaults
	INT_VAR
		list_only = 0
	STR_VAR
		exclude = ~~
	RET 
		filelist
		names
	BEGIN
		LOG ~Override companion portraits from other games with their appropriate replacements~
		LAF copy_npc_portraits 
			INT_VAR defaults = 1 list_only = list_only
			STR_VAR npctype = ~canonnpcs~ game = ~%other_games%~ when = ~exists~ exclude = ~%exclude%~
			RET filelist names
		END
	END

	
	
