`/*
  *  This is a library file of the module, containing functions implementing all logic 
  *  of actual copying and patching.
  */
	

	



/** For a given portrait name `basename`, check for existance of a matching '<basename>.2da' file
  * containing a list of game creatures which should be updated with the portrait `basename`.
  * The file should consist of any lines with a single column each, interpreted as the 
  * creature code matching an existing '<creature>.cre' file.
  *
  * Any existing creatures will have their smaller portrait set to `basename`. 
  * The large portrait entry is determined based on existance of matching portrait files next
  * to '<basename>.[bmp|ref]'. If `basename` ends with an 'M' and there is a matching '*L.bmp' 
  * or '*L.ref' file in the `dir` directory, it is taken as the larger portrait. Otherwise,
  * if `basename` ends with an 'S' and a '*M.bmp' or '*L.bmp' (or '.ref') file with the same prefix 
  * exists, it becomes the larger portrait of the creature instead. In case both searches fail,
  * `basename` itself is used also as the larger portrait entry.
  * 
  * As a consequence, one should create a '.2da' file for the smaller of the two portraits that
  * should be used.
  */  
DEFINE_ACTION_FUNCTION update_creatures
	STR_VAR
		/** Directory with the portrait files being handled (most typically specific to an individual npc). */
		dir = ~~
		/** File name without the '.bmp' (or '.ref') extension which is being copied. */
		basename = ~~
	RET
		/** Number of game creature files affected (including those were no actual change was necessary). */
		creatures_patched = 0
	BEGIN
		//read file with each line containing a creature updated with the current portrait
		COPY  ~%dir%/%basename%.2da~ ~%empty_dir%~  //no copying, simple read
			//determine if there is also a matching larger potrait to use
			OUTER_INNER_PATCH_SAVE largesize ~%basename%~ BEGIN //search for portraitM if this is portraitS
				REPLACE_TEXTUALLY CASE_INSENSITIVE EVALUATE_REGEXP ~S$~ ~M~
			END
			
			PATCH_IF (largesize STR_EQ basename) OR NOT (
			          FILE_EXISTS ~%dir%/%largesize%.bmp~ OR FILE_EXISTS ~%dir%/%largesize%.ref~) THEN BEGIN
				//search for portraitL if this is portraitS/portraitM	   
				OUTER_INNER_PATCH_SAVE largesize ~%basename%~ BEGIN 
					REPLACE_TEXTUALLY CASE_INSENSITIVE EVALUATE_REGEXP ~[SM]$~ ~L~
				END
				PATCH_IF (largesize STR_EQ basename) OR NOT (FILE_EXISTS ~%dir%/%largesize%.bmp~ 
						      OR FILE_EXISTS ~%dir%/%largesize%.ref~) THEN BEGIN
					//search for portraitG if this is portraitS/portraitM/portraitL
					OUTER_INNER_PATCH_SAVE largesize ~%basename%~ BEGIN 
						REPLACE_TEXTUALLY CASE_INSENSITIVE EVALUATE_REGEXP ~[SML]$~ ~G~
					END
					PATCH_IF NOT (FILE_EXISTS ~%dir%/%largesize%.bmp~ //fallback to using this image for both small and large portraits.					              OR FILE_EXISTS ~%dir%/%largesize%.ref~) TEN BEGIN
						OUTER_TEXT_SPRINT largesize ~%basename%~
					END
				END
			END
			
			COUNT_2DA_ROWS 1 creature_count
			
			FOR (i = 0; i < creature_count; ++i) BEGIN
				READ_2DA_ENTRY i 0 1 creature
			
				INNER_ACTION BEGIN
					COPY_EXISTING ~%creature%.cre~ ~override~
						SET creatures_patched += 1
						WRITE_EVALUATED_ASCII 0x34 ~%basename%~ #8 
						WRITE_EVALUATED_ASCII 0x3C ~%largesize%~ #8
					BUT_ONLY_IF_IT_CHANGES
				END									
			END
		IF_EXISTS BUT_ONLY_IF_IT_CHANGES
	
	END
	
	

	
	
/** Similar to update_creatures, verifies for the existance of the given 2da file and returns
  * the number of creatures listed in that file that actually exist in the game. The returned
  * value is the same that would be returned by update_creatures with corresponding parameters,
  * and the file must be a '.2da' file with a creature id (without the '.cre' extension) to update
  * in each line.
  */  
DEFINE_ACTION_FUNCTION patched_creatures
	STR_VAR
		file = ~~
	RET
		number = 0
	BEGIN
		COPY ~%file%~ ~%MOD_FOLDER%~ //just read, don't copy			
			COUNT_2DA_ROWS 1 creature_count
			
			FOR (i = 0; i < creature_count; ++i) BEGIN
				READ_2DA_ENTRY i 0 1 creature
				PATCH_IF FILE_EXISTS_IN_GAME ~%creature%.cre~ THEN BEGIN
					SET number += 1
				END
			END
		IF_EXISTS BUT_ONLY_IF_IT_CHANGES
	END
	
	
	
	
	
	
/** Copy a single portrait file, possibly following a chain of file references (quasi symbolic links).
  * First verifies that the file should be copied at all, based on whether the target portrait already
  * exists in the game and passed overwrite flags. If so, and %path% denotes a '.bmp' file, it is simply
  * copied. Otherwise, if it ends with '.ref', its contents are treated as the path to the target file, 
  * relative to the mod folder, which is then followed recursively. The path can, but doesn't have to,
  * include the '.bmp'/'.ref' extension. In the latter case, existing files with any of these extensions
  * are valid targets. In case of unsupported file extension or a link without a target, a warning 
  * is printed and `0` is returned as %copied%.
  *
  * @returns non-zero iff the file has been copied.
  */	
DEFINE_ACTION_FUNCTION copy_portrait
	INT_VAR
		/** Do not copy, simply resolve any file refs and return `1` if they point to a file that would be copied. */
		list_only = 0
		/** When set to 1 denotes that this is a recursive call being the result of resolving a ref file. */
		chain_call = 0
	STR_VAR
		/** Path to the file that should be copied, either a bmp or symlink-like '.ref'. */
		path = ~~
		/** Target directory to which the final .bmp file should be copied. */
		target = ~~
		/** Target game resource name, including the .bmp extension. */
		name = ~~
		/** Switch which decides if a file should be copied based on its existance in the game. Can be one of:
		  * 'exists' - override only; the file must already exist in the game.
		  * 'not exists' - only new portraits; don't copy if the file already exists
		  * 'always' - all portraits; copy regardless of previous presence.
		  * 'used' - the portrait must exist, or a file with creatures to patch specifies at least one existing creature (default). 
		  */
		when = ~used~ 
	RET
		/** Return code specifying if the file was copied successfully. 
		  * If %list_only% is set, this will be `1` if the file *would* be copied. */
		copied = 1
	BEGIN
		OUTER_TEXT_SPRINT indent ~        ~
		ACTION_IF chain_call THEN BEGIN
			OUTER_TEXT_SPRINT indent ~          ~
		END
		
		ACTION_IF NOT FILE_EXISTS ~%path%~ THEN BEGIN
			ACTION_IF FILE_EXISTS ~%path%.bmp~ THEN BEGIN
				OUTER_TEXT_SPRINT path ~%path%.bmp~
			END ELSE ACTION_IF FILE_EXISTS ~%path%.ref~ THEN BEGIN
				OUTER_TEXT_SPRINT path ~%path%.ref~
			END ELSE BEGIN
				LOG ~%indent%ignoring %name%: %path% (invalid path/ref)~
				OUTER_SET copied = 0
			END

		END
				
	
		ACTION_IF copied THEN BEGIN
			ACTION_IF FILE_EXISTS_IN_GAME ~%name%~ THEN BEGIN
				ACTION_IF (when STR_EQ ~not exists~) THEN BEGIN
					OUTER_SET copied = 0
					LOG ~%indent%ignoring %name%: %path% (game file exists)~
				END
				OUTER_SET file_exists = 1
			END ELSE BEGIN
				ACTION_IF (when STR_EQ ~exists~) THEN BEGIN
					OUTER_SET copied = 0
					LOG ~%indent%ignoring %name%: %path% (game file does not exist)~
				END 
				OUTER_SET file_exists = 0
			END
		END
		
		ACTION_IF copied THEN BEGIN
			//lets try to strip the extension from the filename
			OUTER_INNER_PATCH_SAVE bname ~%path%~ BEGIN
				REPLACE_TEXTUALLY CASE_INSENSITIVE EXACT_MATCH ~.bmp~ ~~
			END
			
			ACTION_IF NOT ~%bname%.bmp~ STR_EQ ~%path%~ THEN BEGIN
				OUTER_INNER_PATCH_SAVE bname ~%path%~ BEGIN
					REPLACE_TEXTUALLY CASE_INSENSITIVE EXACT_MATCH ~.ref~ ~~
				END
				ACTION_IF NOT ~%bname%.ref~ STR_EQ ~%path%~ THEN BEGIN
					OUTER_SET copied = 0
					WARN ~Unsupported file name or type: %path%~
				END
			END
			
			ACTION_IF copied AND file_exists AND when STR_EQ ~used~ THEN BEGIN
				ACTION_IF NOT file_exists AND NOT chain_call AND (when STR_EQ ~used~) THEN BEGIN
					LAF patched_creatures STR_VAR file = ~%bname%.2da~ RET copied = number END
				END
				ACTION_IF NOT copied THEN BEGIN
					LOG ~%indent%ignoring %name%: %path% (game file does not exist and no creatures to patch)~
				END
			END
		
			ACTION_IF copied THEN BEGIN
				ACTION_IF ~%bname%.bmp~ STR_EQ ~%path%~ THEN BEGIN //file name ends with '.bmp'
					ACTION_IF list_only THEN BEGIN
						LOG ~%indent%%name%: %path%~
					END ELSE BEGIN
						COPY ~%path%~ ~%target%/%name%~
					END
				END ELSE BEGIN //file name ends with '.ref'
					COPY ~%path%~ ~%empty_dir%~ //no copy, just read ref target
						COUNT_2DA_ROWS 1 copied
						
						PATCH_IF NOT copied THEN BEGIN
							WARN ~ERROR: Malformed (empty) file ref: %dir%/%filename%~
						
						END ELSE BEGIN
							READ_2DA_ENTRY 0 0 1 newpath

							LOG ~%indent%resolving %path% -> %newpath%~
							LAF copy_portrait 
								INT_VAR list_only = list_only chain_call = 1
								STR_VAR path = ~%newpath%~ target = ~%target%~ name = ~%name%~ when = ~%when%~
								RET copied END								
						END 
					IF_EXISTS
				END
			END
		END	
		
	END
	
	


	
	
/** Copies portrait files listed in an aggregate `2da` 2-column file `refsfile` 
  * (which should have a '.refs' extension). The first column of the file carries
  * the base name of the target portrait file (without a '.bmp' extesion, for example 'ImoenM').
  * The second column is a path to the file which should be copied (and possibly renamed)
  * to directory `%target%` and should be relative to `%MOD_FOLDER%` directory. 
  * It should point to either a '.bmp' or a '.ref' file, and is followed by delegation to `copy_portrait`.
  * The parameters driving the selection of files are interpreted in the same way as by
  * `copy_npc_portraits` function, and similarly, the return value contains the list of
  * files (entries from the first column) which were (or would  be) actually overriden.
  */
DEFINE_ACTION_FUNCTION copy_portrait_refs
	INT_VAR
		/** Don't copy anything, but otherwise behave no differently and return the list of files that 
		  * would be copied were this flag not set. */
		list_only = 0
	STR_VAR
		/** Path to the `.refs` 2da file containing the target name -> source file pairs. */
		refsfile = ~~
		/** Directory to which all files should be copied. */
		target = ~~
		/** List of files to exclude in the shared string format: [/<basename>/]*. */
		exclude = ~~
		/** Switch which decides if a file should be copied based on its existance in the game. Can be one of:
		  * 'exists' - override only; the file must already exist in the game.
		  * 'not exists' - only new portraits; don't copy if the file already exists
		  * 'always' - all portraits; copy regardless of previous presence.
		  * 'used' - the portrait must exist, or a file with creatures to patch specifies at least one existing creature (default). 
		  */
		when = ~used~
	RET
		/** Concatenated list of copied files in the shared format: [/<basename>/]*. */ 
		filelist
	BEGIN
		LOG ~        %refsfile%:~
		COPY ~%refsfile%~ ~%empty_dir%~ //Don't copy, just read
			COUNT_2DA_ROWS 2 filecount
			
			FOR (i = 0; i < filecount; i += 1) BEGIN
				READ_2DA_ENTRY i 0 2 basename
				READ_2DA_ENTRY i 1 2 path
				//STRING_CONTAINS_REGEXP returns the opposite value!
				PATCH_IF (exclude STRING_CONTAINS_REGEXP  ~/%basename%/~) THEN BEGIN
					LAF copy_portrait 
						INT_VAR list_only = list_only chain_call = 1
						STR_VAR path = ~%path%~	target = ~%target%~ name = ~%basename%.bmp~ when = ~%when%~
						RET	proceed = copied END
						
					PATCH_IF proceed THEN BEGIN
						OUTER_TEXT_SPRINT filelist ~%filelist%/%basename%/~
					END											
				END ELSE BEGIN
					LOG ~        excluding %basename%: %path%~
				END
			END
		IF_EXISTS BUT_ONLY_IF_IT_CHANGES
		
	END
	




	
/** For a portrait set given as a single directory (specific to an npc), check for
  * the existance of alternative portrait sets and, unless the run is non-interactive
  * or set to always use default values, present the alternative portraits to the user
  * and prompt them for a selection of one of them. The entries of the list are verbatim
  * folder names under '<dir>/alteratives' in the alphabetical order.
  *
  * The alternatives are searched for in an 'alteratives' directory next to the
  * default portrait files for an npc. If such a directory exists and contains more
  * than one subdirectory, they are assumed to contain portrait sets which can
  * be used to substitute default portraits in the `dir` directory. All these directories
  * should contain the exact same set of files in the respect to their base names and portrait
  * dimensions. Allowed extensions are '.bmp' and '.ref' as handled by the `copy_portrait`
  * function and can differ between the alternative directories and the default npc
  * directory. In particular, it makes sense to have the default portrait be files simply
  * '.ref' file links pointing to actual portraits (or refs) inside of the alternative directory.
  * 
  * Additionally, if the %show_alternatives% global variable is set and an 'alternatives.html' file is present
  * in the proper npc directory (next to the 'alternatives' directory), a viewer is launched to preview the 
  * portraits, providing the install run is interactive. Any lacking files will result in mismatched portraits.
  *
  * If/when the choice of one of the portrait sets is made, aside from copying those files and
  * overriding any already existing portraits, *the portrait files from %dir% are all deleted*.
  * In their place, for every file copied, a '.ref' file is created with the same name, pointing to
  * to the copied file. This makes the choice persistent and changes the 'default' portrait set
  * for the character. In effect, any future automatic overrides of these files when copying will
  * use the previously copied files, without generally undesirable effect of reverting to original portraits.
  *
  * It is the responsibility of the caller to verify if the run is interactive or if for
  * any other reasons the user shouldn't be prompted with the choice but default values should
  * be used instead.
  */
DEFINE_ACTION_FUNCTION select_alternative_portraits
	STR_VAR
		/** The directory corresponding to a portrait set (for example, 
		  * '%MOD_FOLDER%/canonnpcs/bgee/female/Imoen'). */
		dir = ~~
		/** The name of the `dir` directory (with the path prefix stripped, i.e. 'Imoen'). */
		npcname = ~~
		/** Directory to which the files should be copied. */
		target = ~override~
	BEGIN
		ACTION_IF DIRECTORY_EXISTS ~%dir%/alternatives~ THEN BEGIN
			GET_DIRECTORY_ARRAY versions ~%dir%/alternatives~ ~%any_dir%~
						
			OUTER_SET altcount = 0
			ACTION_PHP_EACH versions AS _ => alt BEGIN							
				OUTER_SET altcount += 1
			END
			
			ACTION_IF altcount > 1 THEN BEGIN
				OUTER_SPRINT prompt @504
				PRINT ~%prompt% %npcname%:~
			
				OUTER_SET altcount = 0 //print alternative portrait dirs
				ACTION_PHP_EACH versions AS _ => alt BEGIN
					OUTER_INNER_PATCH_SAVE altdesc ~%alt%~ BEGIN //unqalified directory name
						REPLACE_TEXTUALLY CASE_SENSITIVE EXACT_MATCH ~%dir%/alternatives/~ ~~
					END
					
					PRINT ~[%altcount%] %altdesc%~
					OUTER_SET altcount += 1
				END
				
				//Launch a viewer to show the user a preview of portraits to pick
				ACTION_IF show_alternatives AND FILE_EXISTS ~%dir%/alternatives.html~ THEN BEGIN
					AT_INTERACTIVE_NOW ~VIEW %dir%/alternatives.html~
				END
				
				OUTER_SET idx = altcount //read user choice into idx
				OUTER_WHILE (NOT IS_AN_INT %idx%) OR idx < 0 OR idx >= altcount BEGIN
					PRINT @505
					ACTION_READLN ~idx~
				END
					
				OUTER_SPRINT chosen $versions(~%idx%~)
				ACTION_CLEAR_ARRAY versions
				LOG ~%npcname% alternative %idx%: %chosen%~ 
				
				GET_FILE_ARRAY files ~%chosen%~ ~[^/\\]+\.\(bmp\|ref\)~
				
				//copy the files under chosen directory to override and create references in %dir%
				ACTION_PHP_EACH files AS _ => portrait BEGIN
					OUTER_INNER_PATCH_SAVE filename ~%portrait%~ BEGIN
						REPLACE_TEXTUALLY CASE_SENSITIVE EXACT_MATCH ~%chosen%/~ ~~
					END
					OUTER_INNER_PATCH_SAVE basename ~%filename%~ BEGIN
						REPLACE_TEXTUALLY CASE_INSENSITIVE EXACT_MATCH ~.bmp~ ~~
					END
					ACTION_IF NOT (~%basename%.bmp~ STR_EQ ~%filename%~) THEN BEGIN
						OUTER_INNER_PATCH_SAVE basename ~%filename%~ BEGIN
							REPLACE_TEXTUALLY CASE_INSENSITIVE EXACT_MATCH ~.ref~ ~~
						END
						ACTION_IF NOT (~%basename%.ref~ STR_EQ ~%filename%~) THEN BEGIN
							FAIL ~Unsupported alternative portrait file type: [%portrait%]~
						END
					END
					
					LAF copy_portrait 
						STR_VAR path = ~%portrait%~ name = ~%filename%~ target = ~%target%~ when = ~always~
						RET copied
					END
					ACTION_IF NOT copied THEN BEGIN
						FAIL ~Could not copy alternative portrait for %npcname%: [%portrait%]~
					END
					//COPY ~%portrait%~ ~%target%~
					
					LAF create_ref_file STR_VAR dir = ~%dir%~ name = ~%basename%~ path = ~%portrait%~ END
					
				END
				
			END
		END
	
	END






/** Copies portraits from a single directory. This function is called from copy_npc_portraits
  * for every npc-level directory.
  */
DEFINE_ACTION_FUNCTION copy_portrait_set
	INT_VAR
		/** Copy no files, simply return the list of files that would be copied. 
		  * Return value is the same as without this flag. */
		list_only = 0
		/** Allow the user to select between alternative portraits if available. Superceeded by list_only=1. */
		defaults = -1
	STR_VAR 
		/** The complete path to the directory with the portrait files. */ 
		dir = ~~
		/** Switch which decides if a file should be copied based on its existance in the game. Can be one of:
		  * 'exists' - override only; the file must already exist in the game.
		  * 'not exists' - only new portraits; don't copy if the file already exists
		  * 'always' - all portraits; copy regardless of previous presence.
		  * 'used' - the portrait must exist, or a file with creatures to patch specifies at least one existing creature (default). 
		  */
		when = ~used~
		/** Target directory into which all files are (flatly) copied. */
		target = ~override~
		/** List of file names (without extensions) that should be excluded from copying. 
		  * Each entry on the list should be surrounded with '/'. */
		exclude = ~~
	RET
		/** List of base names of copied files. Each name is surrounded with '/' on both sides:
		  * unless the list is empty, string starts and ends with '/' and each two files are separated by '//'. */
		filelist = ~~
	BEGIN
		
		ACTION_DEFINE_ARRAY portraits BEGIN END
		GET_FILE_ARRAY portraits ~%dir%~ ~^.+\.\(bmp\|ref\|refs\)$~ 
		//OUTER_TEXT_SPRINT copied_files ~~
		
		
		ACTION_PHP_EACH portraits AS _ => path BEGIN //copy all new bmp files to target
			
			OUTER_INNER_PATCH_SAVE filename ~%path%~ BEGIN //unqualified file name
				REPLACE_TEXTUALLY CASE_SENSITIVE EXACT_MATCH ~%dir%/~ ~~
			END
			
			OUTER_INNER_PATCH_SAVE basename ~%filename%~ BEGIN 
				//check if the file actually contains a list of files to be copied
				REPLACE_TEXTUALLY CASE_INSENSITIVE EXACT_MATCH ~.refs~ ~~
			END
			
			
			//A 2-column table with target portrait name and path to the file
			ACTION_IF ~%basename%.refs~ STR_EQ ~%filename%~ THEN BEGIN
				LAF copy_portrait_refs 
					INT_VAR list_only = list_only
					STR_VAR 
						refsfile = ~%path%~ 
						target = ~%target%~
						exclude = ~%exclude%~
						when = ~%when%~
					RET refs = filelist END
				OUTER_SET proceed = 0
				OUTER_TEXT_SPRINT filelist ~%filelist%%refs%~
				
			END ELSE BEGIN //single file (or file ref)
			
				OUTER_INNER_PATCH_SAVE basename ~%filename%~ BEGIN
					REPLACE_TEXTUALLY CASE_INSENSITIVE EXACT_MATCH ~.bmp~ ~~
				END
				ACTION_IF NOT (~%basename%.bmp~ STR_EQ ~%filename%~) THEN BEGIN
					OUTER_INNER_PATCH_SAVE basename ~%filename%~ BEGIN
						REPLACE_TEXTUALLY CASE_INSENSITIVE EXACT_MATCH ~.ref~ ~~
					END 
				END
				//STRING_CONTAINS_REGEXP returns 0 on match!
				ACTION_IF NOT (exclude STRING_CONTAINS_REGEXP ~/%basename%/~) THEN BEGIN
					OUTER_SET proceed = 0
					LOG ~        excluding %filename%~
				END ELSE BEGIN
					LAF copy_portrait 
						INT_VAR list_only = list_only
						STR_VAR
							path = ~%path%~
							target = ~%target%~
							name = ~%basename%.bmp~
							when = ~%when%~
						RET proceed = copied END
				END
				ACTION_IF proceed THEN BEGIN
					OUTER_TEXT_SPRINT filelist ~%filelist%/%basename%/~
				END
			END
			
		END
		
	
	END





	
	
/** Copy portrait files which path is covered by a sequence of regular expressions for individual directories.
  *	The directories on path serve as role/content/gender filter and thus subtries of the collection can be
  * excluded or included. Only the first argument is mandatory, the rest will match all standard subdirectories.
  * If you wish to copy portraits of NPCs regardless of their role, choose %any_npc_type% for npctype.
  *  
  * This function concers itself only if the standard '.bmp' files, symlink-like file refs '.ref' containing
  * a path to the actual file (see `copy_portrait` function's documentation) and '.refs' files aggregating
  * several file links (see `copy_portrait_refs` function's documetation).  Additionally, if a matching 
  * file with a '2da' extension is found for a portrait (i.e. an ImoenM.2da for ImoenM.bmp), it is assumed to
  * contain a list of creature codes (their file names without the '.CRE' extension), one creature file per line,
  * which should be patched with the corresponding portrait. It will be set as both the large and medium sized 
  * portrait (offsets 0x34 and 0x3C) for the creatures, unless:
  * a) the file name ends with 'M' (i.e. ImoenM.bmp) and a corresponding 'L' file exists in the same directory 
  *   (ImoenL.bmp), in which case it is set as the smaller portrait and the 'L' file is set as the larger portrait;
  * b) the file name ends with 'S' (i.e. ImoenS.bmp) and a corresponding 'M' or 'L' file exist in the same 
  *    directory (ImoenM.bmp), in which case it is set as the smaller portrait and the 'M' or 'L' file (in this order)
  *    is set as the larger portrait.
  * In the above case of matching portrait sets, only one '2da' file should be present, or the actions will
  * be applied in undetermined order and overwrite their modifications. See the `update_creatures` function
  * for details.
  *
  * If the defaults parameter is zero, or it is negative and the %manual_alternatives% global variable is set, 
  *`the list_only` parameter is false, and an 'alternatives' directory is present in the npc folder with portrait 
  * files, the user will be prompted with the list of directories and asked to pick one. They should be named 
  * descriptively, with a limitation of disallowed characters '/', '\', '.', and are assumed to contain a file 
  * with the same name for all '.bmp'/'.ref' files in the parent npc directory. 
  * See the `select_alternative_portraits` for more.
  *
  * @returns filelist a string with concatenated portrait names, each surrounded by a pair of '/'.
  * @returns names a string with concatenated names of npc-level directories from which files were copied.
  * @returns filemap - an assoc array mapping paths of every 'npc' (deepest level) directory afected to 
  *                  a string containing all portrait file names (without the .bmp extension) copied 
  *                  from that directory prefixed by '/', i.e. in the format of "\(/<base-file-name>\)*".
  *                  If no files where copied from a directory, it is mapped to an empty string. 
  *                  If no files where copied at all, the map contains a single entry ~~ => ~~.
  */
DEFINE_ACTION_FUNCTION copy_npc_portraits
	INT_VAR
		/** Copy no files, simply return the list of files that would be copied. 
		  * Return value is the same as without this flag. */
		list_only = 0
		/** Allow the user to select between alternative portraits if available. */
		defaults = -1
		/** If not zero, the user will be prompted about every portrait set (npc directory). */
		ask_each = 0
	STR_VAR 
		/** Regexp for name of root directory with npc portraits (alternative from npcs|modnpcs|plotnpcs etc.)*/
		npctype = ~~
		/** Regexp for game directories to cover: bgee|sod|bg2ee */	
		game = ~~
		/** Regexp for gender directory grouping individual npcs. */
		gender = ~male\|female\|other~ 
		/** Regexp for npc directory (i.e. name/identifier). */
		name = ~~ 
		/** Switch which decides if a file should be copied based on its existance in the game. Can be one of:
		  * 'exists' - override only; the file must already exist in the game.
		  * 'not exists' - only new portraits; don't copy if the file already exists
		  * 'always' - all portraits; copy regardless of previous presence.
		  * 'used' - the portrait must exist, or a file with creatures to patch specifies at least one existing creature (default). 
		  */
		when = ~used~
		/** Target directory into which all files are (flatly) copied. */
		target = ~override~
		/** List of file names (without extensions) that should be excluded from copying. 
		  * Each entry on the list should be surrounded with '/'. */
		exclude = ~~
	RET
		/** List of base names of copied files. Each name is surrounded with '/' on both sides:
		  * unless the list is empty, string starts and ends with '/' and each two files are separated by '//'. */
		filelist
		/** List of directories matching %name% which contained at least one file included in %filelist%. 
		  * Directories from all %npctype%/%game%/%gender% branches are listed together and separated by the regexp 
		  * alternative symbol '\|'.
		  */		
		names
	RET_ARRAY
		filemap
	BEGIN
		OUTER_TEXT_SPRINT filelist ~~
		OUTER_TEXT_SPRINT names ~~
		
		ACTION_IF (~%game%~ STRING_EQUAL ~~) THEN BEGIN 
			OUTER_TEXT_SPRINT game ~%game_dirs%~
		END
		ACTION_IF (~%name%~ STRING_EQUAL ~~) THEN BEGIN
			OUTER_TEXT_SPRINT name ~%any_dir%~
		END
		ACTION_IF defaults < 0 THEN BEGIN
			OUTER_SET defaults = (NOT manual_alternatives)
		END
		
		ACTION_IF NOT list_only THEN BEGIN
			ACTION_IF when STR_EQ ~exists~ THEN BEGIN
				PRINT ~Overwrite portraits files in %target% from %MOD_FOLDER%/%npctype%/%game%/%gender%/%name%/~
			END ELSE BEGIN
				PRINT ~Copy portraits from %MOD_FOLDER%/%npctype%/%game%/%gender%/%name%/ to %target%~
			END
		END
		
		ACTION_IF NOT DIRECTORY_EXISTS ~%target%~ THEN BEGIN
			MKDIR ~%target%~
		END
		
		ACTION_DEFINE_ASSOCIATIVE_ARRAY filemap BEGIN END
		
		OUTER_SET npccount = 0
		GET_DIRECTORY_ARRAY roots ~%MOD_FOLDER%~ ~^\(%npctype%\)$~ 
		
		ACTION_PHP_EACH roots AS _ => root BEGIN
			LOG ~%root%:~
			GET_DIRECTORY_ARRAY gamedirs ~%root%~ ~^\(%game%\)$~	
			
			ACTION_PHP_EACH gamedirs AS _ => game BEGIN 
				LOG ~  %game%:~
				GET_DIRECTORY_ARRAY sexes ~%game%~ ~^\(%gender%\)$~
				
				ACTION_PHP_EACH sexes AS _ => sex BEGIN
					LOG ~    %sex%:~
					GET_DIRECTORY_ARRAY npcs ~%sex%~ ~^\(%name%\)$~
				
					ACTION_PHP_EACH npcs AS _ => npc BEGIN
						LOG ~      %npc%:~
						OUTER_INNER_PATCH_SAVE npcname ~%npc%~ BEGIN //unqalified directory name
							REPLACE_TEXTUALLY CASE_SENSITIVE EXACT_MATCH ~%sex%/~ ~~
						END
						
						OUTER_TEXT_SPRINT copied_files ~~
						OUTER_SET proceed = 0
						ACTION_IF ask_each && NOT list_only THEN BEGIN
							LOG ~        verifying if there are any files to be copied before asking the user...~
							LAF copy_portrait_set 
								INT_VAR list_only = 1
								STR_VAR dir = ~%npc%~ when = ~%when%~ exclude = ~%exclude%~ target = ~~
								RET copied_files = filelist END
							
							ACTION_IF NOT (copied_files STR_EQ ~~) THEN BEGIN
								OUTER_TEXT_SPRINT copied_files ~~
								OUTER_SPRINT prompt_prefix @508
								OUTER_SPRINT prompt_suffix @509
								OUTER_TEXT_SPRINT decision ~~ 
								WHILE NOT ((decision STRING_EQUAL_CASE ~I~) || (decision STRING_EQUAL_CASE ~N~)) BEGIN
									PRINT ~  %prompt_prefix% %npcname%%prompt_suffix% ~								
									ACTION_READLN ~decision~									
								END
								ACTION_IF (decision STRING_EQUALS_CASE ~I~) THEN BEGIN
									LOG ~        installing %npcname%:~
									OUTER_SET proceed = 1
								END 
							END								
						END ELSE BEGIN
							OUTER_SET proceed = 1
						END
						
						ACTION_IF proceed THEN BEGIN
							LAF copy_portrait_set
								INT_VAR list_only = list_only
								STR_VAR dir = ~%npc%~ when = ~%when%~ exclude = ~%exclude%~ target = ~%target%~
								RET copied_files = filelist END
						END
						
						ACTION_IF NOT (~%copied_files%~ STR_EQ ~~) THEN BEGIN
							ACTION_IF names STR_EQ ~~ THEN BEGIN
								OUTER_TEXT_SPRINT names ~%npcname%~
							END ELSE BEGIN
								OUTER_TEXT_SPRINT names ~%names%\|%npcname%~
							END
							ACTION_IF NOT list_only THEN BEGIN
								LAF update_creatures 
									STR_VAR dir = ~%npc%~ basename = ~%basename%~ 
									RET creatures = creatures_patched END
								ACTION_IF creatures THEN BEGIN
									LOG ~          patched %creatures% creatures.~
								END
								ACTION_IF NOT defaults THEN BEGIN
									//verify if there is an 'alternatives' subdirectory with alternate files
									LAF select_alternative_portraits STR_VAR
										dir = ~%npc%~ npcname = ~%npcname%~ target = ~%target%~
									END
								END
							END
						END	
							
						OUTER_SET npccount += 1
						ACTION_DEFINE_ASSOCIATIVE_ARRAY filemap BEGIN ~%npc%~ => ~%copied_files%~ END
						OUTER_TEXT_SPRINT filelist ~%filelist%%copied_files%~
				
					END
					ACTION_CLEAR_ARRAY npcs
				END
				ACTION_CLEAR_ARRAY sexes
			END
			ACTION_CLEAR_ARRAY gamedirs
		END
		ACTION_CLEAR_ARRAY roots
		
		LOG ~NPCs/sets: %names%~
		ACTION_IF list_only THEN BEGIN
			LOG ~Listed portraits: %filelist%~
		END ELSE BEGIN
			LOG ~Copied portraits: %filelist%~
		END
		
		ACTION_IF NOT npccount THEN BEGIN
			ACTION_DEFINE_ASSOCIATIVE_ARRAY filemap BEGIN ~~ => ~~ END
		END
		
	END
	

	

/** A minimalistic wrapper over copy_npc_portraits which simply sets list_only = 1. */	
DEFINE_ACTION_FUNCTION list_npc_portraits
	STR_VAR 
		npctype = ~~
		game = ~~
		gender = ~male\|female\|other~ 
		name = ~~ 
		when = ~used~
		exclude = ~~
	RET
		filelist
		names
	RET_ARRAY
		filemap
	BEGIN
		LAF copy_npc_portraits 
			INT_VAR list_only = 1 defaults = 1
			STR_VAR npctype = ~%npctype%~ game = ~%game%~ gender = ~%gender%~ name = ~%name%~
			        when = ~%when%~ exclude = ~%exclude%~ target = ~~
			RET filelist names
			RET_ARRAY filemap
		END
	END




	
	
/** A light wrapper over `copy_npc_portraits`, which overrides all portraits
  * for the official joinable npcs in the game (assuming replacement exists).
  * It simply sets the following parameters: `when = ~exists~`,
  * `npctype = ~canonnpcs~` and `game = ~%any_game%~`. The `list_only` and `exclude`
  * parameters are passed to `copy_npc_portraits` and its returned value is
  * returned to the caller in `filelist`.
  */
DEFINE_ACTION_FUNCTION copy_canon_npc_defaults
	INT_VAR
		list_only = 0
	STR_VAR
		exclude = ~~
	RET 
		filelist
		names
	BEGIN
		LAF copy_npc_portraits 
			INT_VAR defaults = 1
			INT_VAR list_only = list_only
			STR_VAR npctype = ~canonnpcs~ game = ~%any_game%~ when = ~exists~ exclude = ~%exclude%~
			RET filelist names
		END
	END

	
	
